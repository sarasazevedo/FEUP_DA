<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: RoutingManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classRoutingManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RoutingManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RoutingManager_8h_source.html">RoutingManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a62150d1473272d0d37567ab24493ea3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#a62150d1473272d0d37567ab24493ea3e">RoutingManager</a> ()</td></tr>
<tr class="separator:a62150d1473272d0d37567ab24493ea3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5d330dd8a6624fd4d8b2328736e358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#a0d5d330dd8a6624fd4d8b2328736e358">readExtraFullyConnectedGraph</a> (unsigned int nodeNumber)</td></tr>
<tr class="separator:a0d5d330dd8a6624fd4d8b2328736e358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36323221a5583e9223f7b2ccc4df7b85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#a36323221a5583e9223f7b2ccc4df7b85">readRealWorldGraph</a> (string folderName)</td></tr>
<tr class="separator:a36323221a5583e9223f7b2ccc4df7b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bc5b9df4ec317c86907ef3e34ef746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#a85bc5b9df4ec317c86907ef3e34ef746">readToyGraph</a> (string fileName)</td></tr>
<tr class="separator:a85bc5b9df4ec317c86907ef3e34ef746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0326c2b53910242838999882fd67e1f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#a0326c2b53910242838999882fd67e1f3">backtrackingAux</a> (vector&lt; vector&lt; int &gt;&gt; &amp;paths, unordered_map&lt; int, <a class="el" href="classVertex.html">Vertex</a> * &gt; &amp;vertexSet, int currPos, int count, double cost, double &amp;totalDist, vector&lt; int &gt; &amp;path)</td></tr>
<tr class="separator:a0326c2b53910242838999882fd67e1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09fac18376f6b9de10392901c424876"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#ad09fac18376f6b9de10392901c424876">backtracking</a> ()</td></tr>
<tr class="separator:ad09fac18376f6b9de10392901c424876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae817993c9d795fffbe506a97dd742240"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#ae817993c9d795fffbe506a97dd742240">degreesToRadians</a> (double degree)</td></tr>
<tr class="separator:ae817993c9d795fffbe506a97dd742240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa710a1ed3a7815fef2d24720c0636f2a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#aa710a1ed3a7815fef2d24720c0636f2a">haversineDistance</a> (double latitude1, double longitude1, double latitude2, double longitude2)</td></tr>
<tr class="separator:aa710a1ed3a7815fef2d24720c0636f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51745ce0f221b13674fe587cb915ba8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#ac51745ce0f221b13674fe587cb915ba8">calculateDistance</a> (<a class="el" href="classVertex.html">Vertex</a> *v1, <a class="el" href="classVertex.html">Vertex</a> *v2)</td></tr>
<tr class="separator:ac51745ce0f221b13674fe587cb915ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ad13919442d9b0c167db837d0c5c6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#a70ad13919442d9b0c167db837d0c5c6f">TriangularApproximation</a> ()</td></tr>
<tr class="separator:a70ad13919442d9b0c167db837d0c5c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e617cb31e15e652e9d2fda432566e21"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; <a class="el" href="classEdge.html">Edge</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#a3e617cb31e15e652e9d2fda432566e21">calculatePrims</a> ()</td></tr>
<tr class="separator:a3e617cb31e15e652e9d2fda432566e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baf8748355b32579686bf0c7ec77693"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#a6baf8748355b32579686bf0c7ec77693">dfsTour</a> (const vector&lt; vector&lt; <a class="el" href="classEdge.html">Edge</a> &gt;&gt; &amp;mst, int node, vector&lt; bool &gt; &amp;visited, vector&lt; int &gt; &amp;path)</td></tr>
<tr class="separator:a6baf8748355b32579686bf0c7ec77693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399d7b51ed1078f50ac64224bf5487b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRoutingManager.html#a399d7b51ed1078f50ac64224bf5487b3">Faster2ApproximationTSP</a> ()</td></tr>
<tr class="separator:a399d7b51ed1078f50ac64224bf5487b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classRoutingManager.html">RoutingManager</a> class </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a62150d1473272d0d37567ab24493ea3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62150d1473272d0d37567ab24493ea3e">&#9670;&nbsp;</a></span>RoutingManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RoutingManager::RoutingManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad09fac18376f6b9de10392901c424876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09fac18376f6b9de10392901c424876">&#9670;&nbsp;</a></span>backtracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoutingManager::backtracking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executes the backtracking TSP algorithm. Time Complexity: O(n!), where n is the number of vertices. </p>

</div>
</div>
<a id="a0326c2b53910242838999882fd67e1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0326c2b53910242838999882fd67e1f3">&#9670;&nbsp;</a></span>backtrackingAux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoutingManager::backtrackingAux </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; int, <a class="el" href="classVertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertexSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>totalDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursive auxiliary function for the backtracking algorithm. This function is called recursively to explore all possible paths in the graph using backtracking. It finds the shortest path starting from the current position (vertex) and updates the total distance and the corresponding path accordingly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>Vector of vectors storing the paths explored. </td></tr>
    <tr><td class="paramname">vertexSet</td><td>The set of vertices in the graph. </td></tr>
    <tr><td class="paramname">currPos</td><td>The current position (vertex) in the traversal. </td></tr>
    <tr><td class="paramname">count</td><td>The number of vertices visited so far. </td></tr>
    <tr><td class="paramname">cost</td><td>The accumulated cost (distance) of the current path. </td></tr>
    <tr><td class="paramname">totalDist</td><td>The total distance of the shortest path found. </td></tr>
    <tr><td class="paramname">path</td><td>Vector representing the current path being explored. Time Complexity: O(n!), where n is the number of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac51745ce0f221b13674fe587cb915ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51745ce0f221b13674fe587cb915ba8">&#9670;&nbsp;</a></span>calculateDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RoutingManager::calculateDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the distance between two vertices in the graph. This function calculates the distance between two vertices in the graph. If there exists a direct edge between the two vertices, the weight of that edge is returned. Otherwise, the Haversine distance between the geographical coordinates of the vertices is calculated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Pointer to the first vertex. </td></tr>
    <tr><td class="paramname">v2</td><td>Pointer to the second vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the two vertices. Time Complexity: O(1) if direct edge exists, otherwise O(1) for Haversine calculation. </dd></dl>

</div>
</div>
<a id="a3e617cb31e15e652e9d2fda432566e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e617cb31e15e652e9d2fda432566e21">&#9670;&nbsp;</a></span>calculatePrims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; <a class="el" href="classEdge.html">Edge</a> &gt; &gt; RoutingManager::calculatePrims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the Minimum Spanning Tree (MST) of the network using Prim's algorithm. This function initializes all vertices, sets the starting vertex, and processes vertices using a priority queue based on their minimum distances. It adds the shortest edges to the MST until all vertices are visited. </p><dl class="section return"><dt>Returns</dt><dd>A vector of vectors of Edges representing the MST of the network. Time Complexity: O(E log V), where E is the number of edges and V is the number of vertices. </dd></dl>

</div>
</div>
<a id="ae817993c9d795fffbe506a97dd742240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae817993c9d795fffbe506a97dd742240">&#9670;&nbsp;</a></span>degreesToRadians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RoutingManager::degreesToRadians </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts degrees to radians. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>The angle in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle converted to radians. Time Complexity: O(1). </dd></dl>

</div>
</div>
<a id="a6baf8748355b32579686bf0c7ec77693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6baf8748355b32579686bf0c7ec77693">&#9670;&nbsp;</a></span>dfsTour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoutingManager::dfsTour </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; <a class="el" href="classEdge.html">Edge</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>mst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a Depth-First Search (DFS) to generate a tour from the MST. This function recursively visits all vertices starting from a given node and records the path in the order they are visited. The path represents a preorder traversal of the MST. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td>The Minimum Spanning Tree represented as a vector of vectors of Edges. </td></tr>
    <tr><td class="paramname">node</td><td>The starting node for the DFS. </td></tr>
    <tr><td class="paramname">visited</td><td>A vector indicating whether each vertex has been visited. </td></tr>
    <tr><td class="paramname">path</td><td>The path of nodes visited during the DFS. Time Complexity: O(V + E), where V is the number of vertices and E is the number of edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a399d7b51ed1078f50ac64224bf5487b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399d7b51ed1078f50ac64224bf5487b3">&#9670;&nbsp;</a></span>Faster2ApproximationTSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoutingManager::Faster2ApproximationTSP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates a 2-approximation of the Traveling Salesman Problem (TSP) tour using a faster method. This function first computes the MST using a modified Prim's algorithm, then performs a DFS to get a preorder traversal of the MST, which serves as the TSP tour. It then calculates and prints the total distance and execution time. Time Complexity: O(E log V + V), where E is the number of edges and V is the number of vertices. </p>

</div>
</div>
<a id="aa710a1ed3a7815fef2d24720c0636f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa710a1ed3a7815fef2d24720c0636f2a">&#9670;&nbsp;</a></span>haversineDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RoutingManager::haversineDistance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latitude1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>longitude1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>latitude2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>longitude2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the Haversine distance between two points on Earth. This function computes the great-circle distance between two points on the Earth's surface using the Haversine formula. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latitude1</td><td>Latitude of the first point in degrees. </td></tr>
    <tr><td class="paramname">longitude1</td><td>Longitude of the first point in degrees. </td></tr>
    <tr><td class="paramname">latitude2</td><td>Latitude of the second point in degrees. </td></tr>
    <tr><td class="paramname">longitude2</td><td>Longitude of the second point in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the two points in kilometers. Time Complexity: O(1). </dd></dl>

</div>
</div>
<a id="a0d5d330dd8a6624fd4d8b2328736e358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5d330dd8a6624fd4d8b2328736e358">&#9670;&nbsp;</a></span>readExtraFullyConnectedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoutingManager::readExtraFullyConnectedGraph </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nodeNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read extra fully connected graph </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeNumber</td><td>The number of nodes in the graph. Time Complexity: O(n^2), where n is the number of nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36323221a5583e9223f7b2ccc4df7b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36323221a5583e9223f7b2ccc4df7b85">&#9670;&nbsp;</a></span>readRealWorldGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoutingManager::readRealWorldGraph </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>folderName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read real world graph </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">folderName</td><td>The name of the folder containing graph files. Time Complexity: O(n + m), where n is the number of vertices and m is the number of edges in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85bc5b9df4ec317c86907ef3e34ef746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bc5b9df4ec317c86907ef3e34ef746">&#9670;&nbsp;</a></span>readToyGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoutingManager::readToyGraph </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read toy graph </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>The name of the file containing the toy graph. Time Complexity: O(m), where m is the number of edges in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70ad13919442d9b0c167db837d0c5c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ad13919442d9b0c167db837d0c5c6f">&#9670;&nbsp;</a></span>TriangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RoutingManager::TriangularApproximation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform triangular approximation algorithm to find minimum spanning tree. This function applies the triangular approximation algorithm to find a minimum spanning tree (MST) in the graph. It uses Prims algorithm with a priority queue to efficiently select edges that form the MST. If the weight of an edge is not explicitly given, the function calculates the distance between vertices using the Haversine formula. The total distance of the MST and the execution time are printed as output. Time Complexity: O(E log V), where E is the number of edges and V is the number of vertices. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="RoutingManager_8h_source.html">RoutingManager.h</a></li>
<li>RoutingManager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
