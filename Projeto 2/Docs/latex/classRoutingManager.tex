\hypertarget{classRoutingManager}{}\doxysection{Routing\+Manager Class Reference}
\label{classRoutingManager}\index{RoutingManager@{RoutingManager}}


{\ttfamily \#include $<$Routing\+Manager.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classRoutingManager_a62150d1473272d0d37567ab24493ea3e}{Routing\+Manager}} ()
\item 
void \mbox{\hyperlink{classRoutingManager_a0d5d330dd8a6624fd4d8b2328736e358}{read\+Extra\+Fully\+Connected\+Graph}} (unsigned int node\+Number)
\item 
void \mbox{\hyperlink{classRoutingManager_a36323221a5583e9223f7b2ccc4df7b85}{read\+Real\+World\+Graph}} (string folder\+Name)
\item 
void \mbox{\hyperlink{classRoutingManager_a85bc5b9df4ec317c86907ef3e34ef746}{read\+Toy\+Graph}} (string file\+Name)
\item 
void \mbox{\hyperlink{classRoutingManager_a0326c2b53910242838999882fd67e1f3}{backtracking\+Aux}} (vector$<$ vector$<$ int $>$$>$ \&paths, unordered\+\_\+map$<$ int, \mbox{\hyperlink{classVertex}{Vertex}} $\ast$ $>$ \&vertex\+Set, int curr\+Pos, int count, double cost, double \&total\+Dist, vector$<$ int $>$ \&path)
\item 
void \mbox{\hyperlink{classRoutingManager_ad09fac18376f6b9de10392901c424876}{backtracking}} ()
\item 
double \mbox{\hyperlink{classRoutingManager_ae817993c9d795fffbe506a97dd742240}{degrees\+To\+Radians}} (double degree)
\item 
double \mbox{\hyperlink{classRoutingManager_aa710a1ed3a7815fef2d24720c0636f2a}{haversine\+Distance}} (double latitude1, double longitude1, double latitude2, double longitude2)
\item 
double \mbox{\hyperlink{classRoutingManager_ac51745ce0f221b13674fe587cb915ba8}{calculate\+Distance}} (\mbox{\hyperlink{classVertex}{Vertex}} $\ast$v1, \mbox{\hyperlink{classVertex}{Vertex}} $\ast$v2)
\item 
void \mbox{\hyperlink{classRoutingManager_a70ad13919442d9b0c167db837d0c5c6f}{Triangular\+Approximation}} ()
\item 
vector$<$ vector$<$ \mbox{\hyperlink{classEdge}{Edge}} $>$ $>$ \mbox{\hyperlink{classRoutingManager_a3e617cb31e15e652e9d2fda432566e21}{calculate\+Prims}} ()
\item 
void \mbox{\hyperlink{classRoutingManager_a6baf8748355b32579686bf0c7ec77693}{dfs\+Tour}} (const vector$<$ vector$<$ \mbox{\hyperlink{classEdge}{Edge}} $>$$>$ \&mst, int node, vector$<$ bool $>$ \&visited, vector$<$ int $>$ \&path)
\item 
void \mbox{\hyperlink{classRoutingManager_a399d7b51ed1078f50ac64224bf5487b3}{Faster2\+Approximation\+TSP}} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{classRoutingManager}{Routing\+Manager}} class 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classRoutingManager_a62150d1473272d0d37567ab24493ea3e}\label{classRoutingManager_a62150d1473272d0d37567ab24493ea3e}} 
\index{RoutingManager@{RoutingManager}!RoutingManager@{RoutingManager}}
\index{RoutingManager@{RoutingManager}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{RoutingManager()}{RoutingManager()}}
{\footnotesize\ttfamily Routing\+Manager\+::\+Routing\+Manager (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Constructor 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classRoutingManager_ad09fac18376f6b9de10392901c424876}\label{classRoutingManager_ad09fac18376f6b9de10392901c424876}} 
\index{RoutingManager@{RoutingManager}!backtracking@{backtracking}}
\index{backtracking@{backtracking}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{backtracking()}{backtracking()}}
{\footnotesize\ttfamily void Routing\+Manager\+::backtracking (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Executes the backtracking TSP algorithm. Time Complexity\+: O(n!), where n is the number of vertices. \mbox{\Hypertarget{classRoutingManager_a0326c2b53910242838999882fd67e1f3}\label{classRoutingManager_a0326c2b53910242838999882fd67e1f3}} 
\index{RoutingManager@{RoutingManager}!backtrackingAux@{backtrackingAux}}
\index{backtrackingAux@{backtrackingAux}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{backtrackingAux()}{backtrackingAux()}}
{\footnotesize\ttfamily void Routing\+Manager\+::backtracking\+Aux (\begin{DoxyParamCaption}\item[{vector$<$ vector$<$ int $>$$>$ \&}]{paths,  }\item[{unordered\+\_\+map$<$ int, \mbox{\hyperlink{classVertex}{Vertex}} $\ast$ $>$ \&}]{vertex\+Set,  }\item[{int}]{curr\+Pos,  }\item[{int}]{count,  }\item[{double}]{cost,  }\item[{double \&}]{total\+Dist,  }\item[{vector$<$ int $>$ \&}]{path }\end{DoxyParamCaption})}

Recursive auxiliary function for the backtracking algorithm. This function is called recursively to explore all possible paths in the graph using backtracking. It finds the shortest path starting from the current position (vertex) and updates the total distance and the corresponding path accordingly. 
\begin{DoxyParams}{Parameters}
{\em paths} & Vector of vectors storing the paths explored. \\
\hline
{\em vertex\+Set} & The set of vertices in the graph. \\
\hline
{\em curr\+Pos} & The current position (vertex) in the traversal. \\
\hline
{\em count} & The number of vertices visited so far. \\
\hline
{\em cost} & The accumulated cost (distance) of the current path. \\
\hline
{\em total\+Dist} & The total distance of the shortest path found. \\
\hline
{\em path} & Vector representing the current path being explored. Time Complexity\+: O(n!), where n is the number of vertices. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classRoutingManager_ac51745ce0f221b13674fe587cb915ba8}\label{classRoutingManager_ac51745ce0f221b13674fe587cb915ba8}} 
\index{RoutingManager@{RoutingManager}!calculateDistance@{calculateDistance}}
\index{calculateDistance@{calculateDistance}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{calculateDistance()}{calculateDistance()}}
{\footnotesize\ttfamily double Routing\+Manager\+::calculate\+Distance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classVertex}{Vertex}} $\ast$}]{v1,  }\item[{\mbox{\hyperlink{classVertex}{Vertex}} $\ast$}]{v2 }\end{DoxyParamCaption})}

Calculate the distance between two vertices in the graph. This function calculates the distance between two vertices in the graph. If there exists a direct edge between the two vertices, the weight of that edge is returned. Otherwise, the Haversine distance between the geographical coordinates of the vertices is calculated. 
\begin{DoxyParams}{Parameters}
{\em v1} & Pointer to the first vertex. \\
\hline
{\em v2} & Pointer to the second vertex. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The distance between the two vertices. Time Complexity\+: O(1) if direct edge exists, otherwise O(1) for Haversine calculation. 
\end{DoxyReturn}
\mbox{\Hypertarget{classRoutingManager_a3e617cb31e15e652e9d2fda432566e21}\label{classRoutingManager_a3e617cb31e15e652e9d2fda432566e21}} 
\index{RoutingManager@{RoutingManager}!calculatePrims@{calculatePrims}}
\index{calculatePrims@{calculatePrims}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{calculatePrims()}{calculatePrims()}}
{\footnotesize\ttfamily vector$<$ vector$<$ \mbox{\hyperlink{classEdge}{Edge}} $>$ $>$ Routing\+Manager\+::calculate\+Prims (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Calculates the Minimum Spanning Tree (MST) of the network using Prim\textquotesingle{}s algorithm. This function initializes all vertices, sets the starting vertex, and processes vertices using a priority queue based on their minimum distances. It adds the shortest edges to the MST until all vertices are visited. \begin{DoxyReturn}{Returns}
A vector of vectors of Edges representing the MST of the network. Time Complexity\+: O(\+E log V), where E is the number of edges and V is the number of vertices. 
\end{DoxyReturn}
\mbox{\Hypertarget{classRoutingManager_ae817993c9d795fffbe506a97dd742240}\label{classRoutingManager_ae817993c9d795fffbe506a97dd742240}} 
\index{RoutingManager@{RoutingManager}!degreesToRadians@{degreesToRadians}}
\index{degreesToRadians@{degreesToRadians}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{degreesToRadians()}{degreesToRadians()}}
{\footnotesize\ttfamily double Routing\+Manager\+::degrees\+To\+Radians (\begin{DoxyParamCaption}\item[{double}]{degree }\end{DoxyParamCaption})}

Converts degrees to radians. 
\begin{DoxyParams}{Parameters}
{\em degree} & The angle in degrees. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The angle converted to radians. Time Complexity\+: O(1). 
\end{DoxyReturn}
\mbox{\Hypertarget{classRoutingManager_a6baf8748355b32579686bf0c7ec77693}\label{classRoutingManager_a6baf8748355b32579686bf0c7ec77693}} 
\index{RoutingManager@{RoutingManager}!dfsTour@{dfsTour}}
\index{dfsTour@{dfsTour}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{dfsTour()}{dfsTour()}}
{\footnotesize\ttfamily void Routing\+Manager\+::dfs\+Tour (\begin{DoxyParamCaption}\item[{const vector$<$ vector$<$ \mbox{\hyperlink{classEdge}{Edge}} $>$$>$ \&}]{mst,  }\item[{int}]{node,  }\item[{vector$<$ bool $>$ \&}]{visited,  }\item[{vector$<$ int $>$ \&}]{path }\end{DoxyParamCaption})}

Performs a Depth-\/\+First Search (DFS) to generate a tour from the MST. This function recursively visits all vertices starting from a given node and records the path in the order they are visited. The path represents a preorder traversal of the MST. 
\begin{DoxyParams}{Parameters}
{\em mst} & The Minimum Spanning Tree represented as a vector of vectors of Edges. \\
\hline
{\em node} & The starting node for the DFS. \\
\hline
{\em visited} & A vector indicating whether each vertex has been visited. \\
\hline
{\em path} & The path of nodes visited during the DFS. Time Complexity\+: O(V + E), where V is the number of vertices and E is the number of edges. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classRoutingManager_a399d7b51ed1078f50ac64224bf5487b3}\label{classRoutingManager_a399d7b51ed1078f50ac64224bf5487b3}} 
\index{RoutingManager@{RoutingManager}!Faster2ApproximationTSP@{Faster2ApproximationTSP}}
\index{Faster2ApproximationTSP@{Faster2ApproximationTSP}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{Faster2ApproximationTSP()}{Faster2ApproximationTSP()}}
{\footnotesize\ttfamily void Routing\+Manager\+::\+Faster2\+Approximation\+TSP (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Calculates a 2-\/approximation of the Traveling Salesman Problem (TSP) tour using a faster method. This function first computes the MST using a modified Prim\textquotesingle{}s algorithm, then performs a DFS to get a preorder traversal of the MST, which serves as the TSP tour. It then calculates and prints the total distance and execution time. Time Complexity\+: O(E log V + V), where E is the number of edges and V is the number of vertices. \mbox{\Hypertarget{classRoutingManager_aa710a1ed3a7815fef2d24720c0636f2a}\label{classRoutingManager_aa710a1ed3a7815fef2d24720c0636f2a}} 
\index{RoutingManager@{RoutingManager}!haversineDistance@{haversineDistance}}
\index{haversineDistance@{haversineDistance}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{haversineDistance()}{haversineDistance()}}
{\footnotesize\ttfamily double Routing\+Manager\+::haversine\+Distance (\begin{DoxyParamCaption}\item[{double}]{latitude1,  }\item[{double}]{longitude1,  }\item[{double}]{latitude2,  }\item[{double}]{longitude2 }\end{DoxyParamCaption})}

Calculates the Haversine distance between two points on Earth. This function computes the great-\/circle distance between two points on the Earth\textquotesingle{}s surface using the Haversine formula. 
\begin{DoxyParams}{Parameters}
{\em latitude1} & Latitude of the first point in degrees. \\
\hline
{\em longitude1} & Longitude of the first point in degrees. \\
\hline
{\em latitude2} & Latitude of the second point in degrees. \\
\hline
{\em longitude2} & Longitude of the second point in degrees. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The distance between the two points in kilometers. Time Complexity\+: O(1). 
\end{DoxyReturn}
\mbox{\Hypertarget{classRoutingManager_a0d5d330dd8a6624fd4d8b2328736e358}\label{classRoutingManager_a0d5d330dd8a6624fd4d8b2328736e358}} 
\index{RoutingManager@{RoutingManager}!readExtraFullyConnectedGraph@{readExtraFullyConnectedGraph}}
\index{readExtraFullyConnectedGraph@{readExtraFullyConnectedGraph}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{readExtraFullyConnectedGraph()}{readExtraFullyConnectedGraph()}}
{\footnotesize\ttfamily void Routing\+Manager\+::read\+Extra\+Fully\+Connected\+Graph (\begin{DoxyParamCaption}\item[{unsigned int}]{node\+Number }\end{DoxyParamCaption})}

Read extra fully connected graph 
\begin{DoxyParams}{Parameters}
{\em node\+Number} & The number of nodes in the graph. Time Complexity\+: O(n$^\wedge$2), where n is the number of nodes. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classRoutingManager_a36323221a5583e9223f7b2ccc4df7b85}\label{classRoutingManager_a36323221a5583e9223f7b2ccc4df7b85}} 
\index{RoutingManager@{RoutingManager}!readRealWorldGraph@{readRealWorldGraph}}
\index{readRealWorldGraph@{readRealWorldGraph}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{readRealWorldGraph()}{readRealWorldGraph()}}
{\footnotesize\ttfamily void Routing\+Manager\+::read\+Real\+World\+Graph (\begin{DoxyParamCaption}\item[{string}]{folder\+Name }\end{DoxyParamCaption})}

Read real world graph 
\begin{DoxyParams}{Parameters}
{\em folder\+Name} & The name of the folder containing graph files. Time Complexity\+: O(n + m), where n is the number of vertices and m is the number of edges in the graph. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classRoutingManager_a85bc5b9df4ec317c86907ef3e34ef746}\label{classRoutingManager_a85bc5b9df4ec317c86907ef3e34ef746}} 
\index{RoutingManager@{RoutingManager}!readToyGraph@{readToyGraph}}
\index{readToyGraph@{readToyGraph}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{readToyGraph()}{readToyGraph()}}
{\footnotesize\ttfamily void Routing\+Manager\+::read\+Toy\+Graph (\begin{DoxyParamCaption}\item[{string}]{file\+Name }\end{DoxyParamCaption})}

Read toy graph 
\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the file containing the toy graph. Time Complexity\+: O(m), where m is the number of edges in the graph. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classRoutingManager_a70ad13919442d9b0c167db837d0c5c6f}\label{classRoutingManager_a70ad13919442d9b0c167db837d0c5c6f}} 
\index{RoutingManager@{RoutingManager}!TriangularApproximation@{TriangularApproximation}}
\index{TriangularApproximation@{TriangularApproximation}!RoutingManager@{RoutingManager}}
\doxysubsubsection{\texorpdfstring{TriangularApproximation()}{TriangularApproximation()}}
{\footnotesize\ttfamily void Routing\+Manager\+::\+Triangular\+Approximation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Perform triangular approximation algorithm to find minimum spanning tree. This function applies the triangular approximation algorithm to find a minimum spanning tree (MST) in the graph. It uses Prims algorithm with a priority queue to efficiently select edges that form the MST. If the weight of an edge is not explicitly given, the function calculates the distance between vertices using the Haversine formula. The total distance of the MST and the execution time are printed as output. Time Complexity\+: O(\+E log V), where E is the number of edges and V is the number of vertices. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Routing\+Manager.\+h\item 
Routing\+Manager.\+cpp\end{DoxyCompactItemize}
